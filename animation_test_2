import random
import numpy as np
import networkx as nx
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from deap import base, creator, tools, algorithms
import sys

# 初始化遗传算法环境
creator.create("FitnessMin", base.Fitness, weights=(-1.0,))
creator.create("Individual", list, fitness=creator.FitnessMin)

# 功能函数：计算给定路径的总距离
def evalTSP(individual, distance_matrix, start_node):
    # 确保路径始终从指定的起点开始
    path = [start_node] + [node for node in individual if node != start_node]
    distance = 0
    for i in range(len(path) - 1):
        if distance_matrix[path[i], path[i + 1]] == sys.maxsize:
            return sys.maxsize,  # 如果路径包含无限大权重，则返回无限大
        distance += distance_matrix[path[i], path[i + 1]]
    distance += distance_matrix[path[-1], path[0]]  # 路径封闭
    return distance,

# 生成图
def generate_graph(edges, num_nodes):
    G = nx.Graph()
    G.add_nodes_from(range(num_nodes))
    for u, v, w in edges:
        G.add_edge(u, v, weight=w)
    max_weight = sys.maxsize
    for u, v in G.edges():
        if 'weight' not in G.edges[u, v]:
            G.edges[u, v]['weight'] = max_weight
    return G

def main():
    num_nodes = int(input("Enter the number of nodes: "))
    num_edges = int(input("Enter the number of edges: "))
    edges = []
    for i in range(num_edges):
        u, v, w = map(int, input(f"Enter edge {i + 1} in the format 'u v w': ").split())
        edges.append((u, v, w))
    
    G = generate_graph(edges, num_nodes)
    start_node = int(input("Enter the start node: "))

    distance_matrix = nx.to_numpy_array(G, weight='weight')
    
    toolbox = base.Toolbox()
    node_list = list(range(num_nodes))
    node_list.remove(start_node)  # 移除起始节点以固定起始位置
    toolbox.register("indices", random.sample, node_list, len(node_list))
    toolbox.register("individual", tools.initIterate, creator.Individual, toolbox.indices)
    toolbox.register("population", tools.initRepeat, list, toolbox.individual)
    toolbox.register("mate", tools.cxOrdered)
    toolbox.register("mutate", tools.mutShuffleIndexes, indpb=0.05)
    toolbox.register("select", tools.selTournament, tournsize=3)
    toolbox.register("evaluate", evalTSP, distance_matrix=distance_matrix, start_node=start_node)
    
    population = toolbox.population(n=300)
    ngen = 200
    cxpb = 0.7
    mutpb = 0.2

    for gen in range(ngen):
        algorithms.eaSimple(population, toolbox, cxpb, mutpb, 1, verbose=False)
    
    best_individual = tools.selBest(population, 1)[0]
    path = [start_node] + best_individual + [start_node]  # 闭合路径并确保起点和终点为 start_node

    # 设置动画绘图
    fig, ax = plt.subplots()
    pos = nx.spring_layout(G, seed=42)  # 布局算法并设置种子确保布局一致

    def update(num):
        ax.clear()
        nx.draw(G, pos, ax=ax, with_labels=True, node_color='lightblue', node_size=500)
        nx.draw_networkx_nodes(G, pos, nodelist=[start_node], node_color='yellow', node_size=700)
        edge_labels = nx.get_edge_attributes(G, 'weight')
        nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, ax=ax)
        if num > 0:
            nx.draw_networkx_edges(G, pos, edgelist=list(zip(path[:num], path[1:num+1])), width=2, edge_color='blue')
        ax.set_title(f'Path Step: {num}/{len(path)-1}')

    ani = FuncAnimation(fig, update, frames=len(path), repeat=True)
    plt.show()

    print('最佳路径: ', path)
    print('最短距离: ', evalTSP(best_individual, distance_matrix, start_node)[0])

if __name__ == "__main__":
    main()
